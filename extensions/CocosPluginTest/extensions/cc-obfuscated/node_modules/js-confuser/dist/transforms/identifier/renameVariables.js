"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = require("assert");

var _order = require("../../order");

var _traverse = require("../../traverse");

var _identifiers = require("../../util/identifiers");

var _insert = require("../../util/insert");

var _transform = _interopRequireDefault(require("../transform"));

var _constants = require("../../constants");

var _probability = require("../../probability");

var _variableAnalysis = _interopRequireDefault(require("./variableAnalysis"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Rename variables to randomly generated names.
 *
 * - Attempts to re-use already generated names in nested scopes.
 */
class RenameVariables extends _transform.default {
  // Generator object
  // Names already used
  // Map of Context->Object of changes
  // Ref to VariableAnalysis data
  constructor(o) {
    super(o, _order.ObfuscateOrder.RenameVariables);

    _defineProperty(this, "gen", void 0);

    _defineProperty(this, "generated", void 0);

    _defineProperty(this, "changed", void 0);

    _defineProperty(this, "variableAnalysis", void 0);

    this.changed = new Map();
    this.variableAnalysis = new _variableAnalysis.default(o);
    this.before.push(this.variableAnalysis);
    this.gen = this.getGenerator();
    this.generated = [];
  }

  match(object, parents) {
    return (0, _insert.isContext)(object);
  }

  transform(object, parents) {
    var isGlobal = object.type == "Program";
    var type = isGlobal ? "root" : (0, _insert.isVarContext)(object) ? "var" : (0, _insert.isLexContext)(object) ? "lex" : undefined;
    (0, _assert.ok)(type);
    var newNames = Object.create(null);
    var defined = this.variableAnalysis.defined.get(object) || new Set();
    var references = this.variableAnalysis.references.get(object) || new Set();

    if (!defined && !this.changed.has(object)) {
      this.changed.set(object, Object.create(null));
      return;
    }

    var possible = new Set();

    if (this.generated.length && !isGlobal) {
      var allReferences = new Set(references || []);
      var nope = new Set(defined);
      (0, _traverse.walk)(object, [], (o, p) => {
        var ref = this.variableAnalysis.references.get(o);

        if (ref) {
          ref.forEach(x => allReferences.add(x));
        }

        var def = this.variableAnalysis.defined.get(o);

        if (def) {
          def.forEach(x => allReferences.add(x));
        }
      });
      var passed = new Set();
      parents.forEach(p => {
        var changes = this.changed.get(p);

        if (changes) {
          Object.keys(changes).forEach(x => {
            var name = changes[x];

            if (!allReferences.has(x)) {
              passed.add(name);
            } else {
              nope.add(name);
            }
          });
        }
      });
      nope.forEach(x => passed.delete(x));
      possible = passed;
    }

    defined.forEach(name => {
      if ((isGlobal && !name.startsWith("__p_") ? (0, _probability.ComputeProbabilityMap)(this.options.renameGlobals, x => x, name) : true) && (0, _probability.ComputeProbabilityMap)(this.options.renameVariables, x => x, name, isGlobal)) {
        // Fix 2. Ensure global names aren't overridden
        var newName;

        do {
          if (possible.size) {
            var first = possible.values().next().value;
            possible.delete(first);
            newName = first;
          } else {
            // Fix 1. Use `generateIdentifier` over `gen.generate()` so Integrity can get unique variable names
            var g = this.generateIdentifier();
            newName = g;
            this.generated.push(g);
          }
        } while (this.variableAnalysis.globals.has(newName));

        newNames[name] = newName;
      } else {
        newNames[name] = name;
      }
    });
    this.changed.set(object, newNames);
    (0, _traverse.walk)(object, parents, (o, p) => {
      if (o.type == "Identifier") {
        if (_constants.reservedIdentifiers.has(o.name) || this.options.globalVariables.has(o.name)) {
          return;
        }

        var info = (0, _identifiers.getIdentifierInfo)(o, p);

        if (info.spec.isExported) {
          return;
        }

        if (!info.spec.isReferenced) {
          return;
        }

        var contexts = [o, ...p].filter(x => (0, _insert.isContext)(x));
        var newName = null;

        for (var check of contexts) {
          if (this.variableAnalysis.defined.has(check) && this.variableAnalysis.defined.get(check).has(o.name)) {
            if (this.changed.has(check) && this.changed.get(check)[o.name]) {
              newName = this.changed.get(check)[o.name];
              break;
            }
          }
        }

        if (newName && typeof newName === "string") {
          if (o.$renamed) {
            return;
          } // console.log(o.name, "->", newName);


          o.name = newName;
          o.$renamed = true;
        }
      }
    });
  }

}

exports.default = RenameVariables;